// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package io

import (
	"context"
	"os"

	"github.com/desertwitch/gover/internal/schema"
	mock "github.com/stretchr/testify/mock"
	"golang.org/x/sys/unix"
)

// newMock_fsProvider creates a new instance of mock_fsProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_fsProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_fsProvider {
	mock := &mock_fsProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_fsProvider is an autogenerated mock type for the fsProvider type
type mock_fsProvider struct {
	mock.Mock
}

type mock_fsProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_fsProvider) EXPECT() *mock_fsProvider_Expecter {
	return &mock_fsProvider_Expecter{mock: &_m.Mock}
}

// HasEnoughFreeSpace provides a mock function for the type mock_fsProvider
func (_mock *mock_fsProvider) HasEnoughFreeSpace(s schema.Storage, minFree uint64, fileSize uint64) (bool, error) {
	ret := _mock.Called(s, minFree, fileSize)

	if len(ret) == 0 {
		panic("no return value specified for HasEnoughFreeSpace")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(schema.Storage, uint64, uint64) (bool, error)); ok {
		return returnFunc(s, minFree, fileSize)
	}
	if returnFunc, ok := ret.Get(0).(func(schema.Storage, uint64, uint64) bool); ok {
		r0 = returnFunc(s, minFree, fileSize)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(schema.Storage, uint64, uint64) error); ok {
		r1 = returnFunc(s, minFree, fileSize)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_fsProvider_HasEnoughFreeSpace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasEnoughFreeSpace'
type mock_fsProvider_HasEnoughFreeSpace_Call struct {
	*mock.Call
}

// HasEnoughFreeSpace is a helper method to define mock.On call
//   - s schema.Storage
//   - minFree uint64
//   - fileSize uint64
func (_e *mock_fsProvider_Expecter) HasEnoughFreeSpace(s interface{}, minFree interface{}, fileSize interface{}) *mock_fsProvider_HasEnoughFreeSpace_Call {
	return &mock_fsProvider_HasEnoughFreeSpace_Call{Call: _e.mock.On("HasEnoughFreeSpace", s, minFree, fileSize)}
}

func (_c *mock_fsProvider_HasEnoughFreeSpace_Call) Run(run func(s schema.Storage, minFree uint64, fileSize uint64)) *mock_fsProvider_HasEnoughFreeSpace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.Storage
		if args[0] != nil {
			arg0 = args[0].(schema.Storage)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_fsProvider_HasEnoughFreeSpace_Call) Return(b bool, err error) *mock_fsProvider_HasEnoughFreeSpace_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mock_fsProvider_HasEnoughFreeSpace_Call) RunAndReturn(run func(s schema.Storage, minFree uint64, fileSize uint64) (bool, error)) *mock_fsProvider_HasEnoughFreeSpace_Call {
	_c.Call.Return(run)
	return _c
}

// IsEmptyFolder provides a mock function for the type mock_fsProvider
func (_mock *mock_fsProvider) IsEmptyFolder(path string) (bool, error) {
	ret := _mock.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsEmptyFolder")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return returnFunc(path)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(path)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(path)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_fsProvider_IsEmptyFolder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsEmptyFolder'
type mock_fsProvider_IsEmptyFolder_Call struct {
	*mock.Call
}

// IsEmptyFolder is a helper method to define mock.On call
//   - path string
func (_e *mock_fsProvider_Expecter) IsEmptyFolder(path interface{}) *mock_fsProvider_IsEmptyFolder_Call {
	return &mock_fsProvider_IsEmptyFolder_Call{Call: _e.mock.On("IsEmptyFolder", path)}
}

func (_c *mock_fsProvider_IsEmptyFolder_Call) Run(run func(path string)) *mock_fsProvider_IsEmptyFolder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_fsProvider_IsEmptyFolder_Call) Return(b bool, err error) *mock_fsProvider_IsEmptyFolder_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mock_fsProvider_IsEmptyFolder_Call) RunAndReturn(run func(path string) (bool, error)) *mock_fsProvider_IsEmptyFolder_Call {
	_c.Call.Return(run)
	return _c
}

// IsInUse provides a mock function for the type mock_fsProvider
func (_mock *mock_fsProvider) IsInUse(path string) bool {
	ret := _mock.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsInUse")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(path)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// mock_fsProvider_IsInUse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsInUse'
type mock_fsProvider_IsInUse_Call struct {
	*mock.Call
}

// IsInUse is a helper method to define mock.On call
//   - path string
func (_e *mock_fsProvider_Expecter) IsInUse(path interface{}) *mock_fsProvider_IsInUse_Call {
	return &mock_fsProvider_IsInUse_Call{Call: _e.mock.On("IsInUse", path)}
}

func (_c *mock_fsProvider_IsInUse_Call) Run(run func(path string)) *mock_fsProvider_IsInUse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_fsProvider_IsInUse_Call) Return(b bool) *mock_fsProvider_IsInUse_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *mock_fsProvider_IsInUse_Call) RunAndReturn(run func(path string) bool) *mock_fsProvider_IsInUse_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_osProvider creates a new instance of mock_osProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_osProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_osProvider {
	mock := &mock_osProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_osProvider is an autogenerated mock type for the osProvider type
type mock_osProvider struct {
	mock.Mock
}

type mock_osProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_osProvider) EXPECT() *mock_osProvider_Expecter {
	return &mock_osProvider_Expecter{mock: &_m.Mock}
}

// Open provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Open(name string) (*os.File, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 *os.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*os.File, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *os.File); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type mock_osProvider_Open_Call struct {
	*mock.Call
}

// Open is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Open(name interface{}) *mock_osProvider_Open_Call {
	return &mock_osProvider_Open_Call{Call: _e.mock.On("Open", name)}
}

func (_c *mock_osProvider_Open_Call) Run(run func(name string)) *mock_osProvider_Open_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Open_Call) Return(file *os.File, err error) *mock_osProvider_Open_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *mock_osProvider_Open_Call) RunAndReturn(run func(name string) (*os.File, error)) *mock_osProvider_Open_Call {
	_c.Call.Return(run)
	return _c
}

// OpenFile provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	ret := _mock.Called(name, flag, perm)

	if len(ret) == 0 {
		panic("no return value specified for OpenFile")
	}

	var r0 *os.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, int, os.FileMode) (*os.File, error)); ok {
		return returnFunc(name, flag, perm)
	}
	if returnFunc, ok := ret.Get(0).(func(string, int, os.FileMode) *os.File); ok {
		r0 = returnFunc(name, flag, perm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, int, os.FileMode) error); ok {
		r1 = returnFunc(name, flag, perm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_OpenFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenFile'
type mock_osProvider_OpenFile_Call struct {
	*mock.Call
}

// OpenFile is a helper method to define mock.On call
//   - name string
//   - flag int
//   - perm os.FileMode
func (_e *mock_osProvider_Expecter) OpenFile(name interface{}, flag interface{}, perm interface{}) *mock_osProvider_OpenFile_Call {
	return &mock_osProvider_OpenFile_Call{Call: _e.mock.On("OpenFile", name, flag, perm)}
}

func (_c *mock_osProvider_OpenFile_Call) Run(run func(name string, flag int, perm os.FileMode)) *mock_osProvider_OpenFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 os.FileMode
		if args[2] != nil {
			arg2 = args[2].(os.FileMode)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_osProvider_OpenFile_Call) Return(file *os.File, err error) *mock_osProvider_OpenFile_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *mock_osProvider_OpenFile_Call) RunAndReturn(run func(name string, flag int, perm os.FileMode) (*os.File, error)) *mock_osProvider_OpenFile_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Remove(name string) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_osProvider_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type mock_osProvider_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Remove(name interface{}) *mock_osProvider_Remove_Call {
	return &mock_osProvider_Remove_Call{Call: _e.mock.On("Remove", name)}
}

func (_c *mock_osProvider_Remove_Call) Run(run func(name string)) *mock_osProvider_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Remove_Call) Return(err error) *mock_osProvider_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_osProvider_Remove_Call) RunAndReturn(run func(name string) error) *mock_osProvider_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Rename(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_osProvider_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type mock_osProvider_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_osProvider_Expecter) Rename(oldpath interface{}, newpath interface{}) *mock_osProvider_Rename_Call {
	return &mock_osProvider_Rename_Call{Call: _e.mock.On("Rename", oldpath, newpath)}
}

func (_c *mock_osProvider_Rename_Call) Run(run func(oldpath string, newpath string)) *mock_osProvider_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_osProvider_Rename_Call) Return(err error) *mock_osProvider_Rename_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_osProvider_Rename_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_osProvider_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// Stat provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Stat(name string) (os.FileInfo, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Stat")
	}

	var r0 os.FileInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (os.FileInfo, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) os.FileInfo); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(os.FileInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_Stat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stat'
type mock_osProvider_Stat_Call struct {
	*mock.Call
}

// Stat is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Stat(name interface{}) *mock_osProvider_Stat_Call {
	return &mock_osProvider_Stat_Call{Call: _e.mock.On("Stat", name)}
}

func (_c *mock_osProvider_Stat_Call) Run(run func(name string)) *mock_osProvider_Stat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Stat_Call) Return(v os.FileInfo, err error) *mock_osProvider_Stat_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *mock_osProvider_Stat_Call) RunAndReturn(run func(name string) (os.FileInfo, error)) *mock_osProvider_Stat_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_unixProvider creates a new instance of mock_unixProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_unixProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_unixProvider {
	mock := &mock_unixProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_unixProvider is an autogenerated mock type for the unixProvider type
type mock_unixProvider struct {
	mock.Mock
}

type mock_unixProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_unixProvider) EXPECT() *mock_unixProvider_Expecter {
	return &mock_unixProvider_Expecter{mock: &_m.Mock}
}

// Chmod provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Chmod(path string, mode uint32) error {
	ret := _mock.Called(path, mode)

	if len(ret) == 0 {
		panic("no return value specified for Chmod")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, uint32) error); ok {
		r0 = returnFunc(path, mode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Chmod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chmod'
type mock_unixProvider_Chmod_Call struct {
	*mock.Call
}

// Chmod is a helper method to define mock.On call
//   - path string
//   - mode uint32
func (_e *mock_unixProvider_Expecter) Chmod(path interface{}, mode interface{}) *mock_unixProvider_Chmod_Call {
	return &mock_unixProvider_Chmod_Call{Call: _e.mock.On("Chmod", path, mode)}
}

func (_c *mock_unixProvider_Chmod_Call) Run(run func(path string, mode uint32)) *mock_unixProvider_Chmod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Chmod_Call) Return(err error) *mock_unixProvider_Chmod_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Chmod_Call) RunAndReturn(run func(path string, mode uint32) error) *mock_unixProvider_Chmod_Call {
	_c.Call.Return(run)
	return _c
}

// Chown provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Chown(path string, uid int, gid int) error {
	ret := _mock.Called(path, uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Chown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = returnFunc(path, uid, gid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Chown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chown'
type mock_unixProvider_Chown_Call struct {
	*mock.Call
}

// Chown is a helper method to define mock.On call
//   - path string
//   - uid int
//   - gid int
func (_e *mock_unixProvider_Expecter) Chown(path interface{}, uid interface{}, gid interface{}) *mock_unixProvider_Chown_Call {
	return &mock_unixProvider_Chown_Call{Call: _e.mock.On("Chown", path, uid, gid)}
}

func (_c *mock_unixProvider_Chown_Call) Run(run func(path string, uid int, gid int)) *mock_unixProvider_Chown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Chown_Call) Return(err error) *mock_unixProvider_Chown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Chown_Call) RunAndReturn(run func(path string, uid int, gid int) error) *mock_unixProvider_Chown_Call {
	_c.Call.Return(run)
	return _c
}

// Lchown provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Lchown(path string, uid int, gid int) error {
	ret := _mock.Called(path, uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Lchown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = returnFunc(path, uid, gid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Lchown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lchown'
type mock_unixProvider_Lchown_Call struct {
	*mock.Call
}

// Lchown is a helper method to define mock.On call
//   - path string
//   - uid int
//   - gid int
func (_e *mock_unixProvider_Expecter) Lchown(path interface{}, uid interface{}, gid interface{}) *mock_unixProvider_Lchown_Call {
	return &mock_unixProvider_Lchown_Call{Call: _e.mock.On("Lchown", path, uid, gid)}
}

func (_c *mock_unixProvider_Lchown_Call) Run(run func(path string, uid int, gid int)) *mock_unixProvider_Lchown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Lchown_Call) Return(err error) *mock_unixProvider_Lchown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Lchown_Call) RunAndReturn(run func(path string, uid int, gid int) error) *mock_unixProvider_Lchown_Call {
	_c.Call.Return(run)
	return _c
}

// Link provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Link(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Link")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Link_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Link'
type mock_unixProvider_Link_Call struct {
	*mock.Call
}

// Link is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_unixProvider_Expecter) Link(oldpath interface{}, newpath interface{}) *mock_unixProvider_Link_Call {
	return &mock_unixProvider_Link_Call{Call: _e.mock.On("Link", oldpath, newpath)}
}

func (_c *mock_unixProvider_Link_Call) Run(run func(oldpath string, newpath string)) *mock_unixProvider_Link_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Link_Call) Return(err error) *mock_unixProvider_Link_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Link_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_unixProvider_Link_Call {
	_c.Call.Return(run)
	return _c
}

// Mkdir provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Mkdir(path string, mode uint32) error {
	ret := _mock.Called(path, mode)

	if len(ret) == 0 {
		panic("no return value specified for Mkdir")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, uint32) error); ok {
		r0 = returnFunc(path, mode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Mkdir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mkdir'
type mock_unixProvider_Mkdir_Call struct {
	*mock.Call
}

// Mkdir is a helper method to define mock.On call
//   - path string
//   - mode uint32
func (_e *mock_unixProvider_Expecter) Mkdir(path interface{}, mode interface{}) *mock_unixProvider_Mkdir_Call {
	return &mock_unixProvider_Mkdir_Call{Call: _e.mock.On("Mkdir", path, mode)}
}

func (_c *mock_unixProvider_Mkdir_Call) Run(run func(path string, mode uint32)) *mock_unixProvider_Mkdir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Mkdir_Call) Return(err error) *mock_unixProvider_Mkdir_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Mkdir_Call) RunAndReturn(run func(path string, mode uint32) error) *mock_unixProvider_Mkdir_Call {
	_c.Call.Return(run)
	return _c
}

// Symlink provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Symlink(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Symlink")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Symlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Symlink'
type mock_unixProvider_Symlink_Call struct {
	*mock.Call
}

// Symlink is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_unixProvider_Expecter) Symlink(oldpath interface{}, newpath interface{}) *mock_unixProvider_Symlink_Call {
	return &mock_unixProvider_Symlink_Call{Call: _e.mock.On("Symlink", oldpath, newpath)}
}

func (_c *mock_unixProvider_Symlink_Call) Run(run func(oldpath string, newpath string)) *mock_unixProvider_Symlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Symlink_Call) Return(err error) *mock_unixProvider_Symlink_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Symlink_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_unixProvider_Symlink_Call {
	_c.Call.Return(run)
	return _c
}

// UtimesNano provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) UtimesNano(path string, times []unix.Timespec) error {
	ret := _mock.Called(path, times)

	if len(ret) == 0 {
		panic("no return value specified for UtimesNano")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, []unix.Timespec) error); ok {
		r0 = returnFunc(path, times)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_UtimesNano_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UtimesNano'
type mock_unixProvider_UtimesNano_Call struct {
	*mock.Call
}

// UtimesNano is a helper method to define mock.On call
//   - path string
//   - times []unix.Timespec
func (_e *mock_unixProvider_Expecter) UtimesNano(path interface{}, times interface{}) *mock_unixProvider_UtimesNano_Call {
	return &mock_unixProvider_UtimesNano_Call{Call: _e.mock.On("UtimesNano", path, times)}
}

func (_c *mock_unixProvider_UtimesNano_Call) Run(run func(path string, times []unix.Timespec)) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []unix.Timespec
		if args[1] != nil {
			arg1 = args[1].([]unix.Timespec)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_UtimesNano_Call) Return(err error) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_UtimesNano_Call) RunAndReturn(run func(path string, times []unix.Timespec) error) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_ioTargetQueue creates a new instance of mock_ioTargetQueue. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_ioTargetQueue(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_ioTargetQueue {
	mock := &mock_ioTargetQueue{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_ioTargetQueue is an autogenerated mock type for the ioTargetQueue type
type mock_ioTargetQueue struct {
	mock.Mock
}

type mock_ioTargetQueue_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_ioTargetQueue) EXPECT() *mock_ioTargetQueue_Expecter {
	return &mock_ioTargetQueue_Expecter{mock: &_m.Mock}
}

// AddBytesTransfered provides a mock function for the type mock_ioTargetQueue
func (_mock *mock_ioTargetQueue) AddBytesTransfered(bytes uint64) {
	_mock.Called(bytes)
	return
}

// mock_ioTargetQueue_AddBytesTransfered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddBytesTransfered'
type mock_ioTargetQueue_AddBytesTransfered_Call struct {
	*mock.Call
}

// AddBytesTransfered is a helper method to define mock.On call
//   - bytes uint64
func (_e *mock_ioTargetQueue_Expecter) AddBytesTransfered(bytes interface{}) *mock_ioTargetQueue_AddBytesTransfered_Call {
	return &mock_ioTargetQueue_AddBytesTransfered_Call{Call: _e.mock.On("AddBytesTransfered", bytes)}
}

func (_c *mock_ioTargetQueue_AddBytesTransfered_Call) Run(run func(bytes uint64)) *mock_ioTargetQueue_AddBytesTransfered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_ioTargetQueue_AddBytesTransfered_Call) Return() *mock_ioTargetQueue_AddBytesTransfered_Call {
	_c.Call.Return()
	return _c
}

func (_c *mock_ioTargetQueue_AddBytesTransfered_Call) RunAndReturn(run func(bytes uint64)) *mock_ioTargetQueue_AddBytesTransfered_Call {
	_c.Run(run)
	return _c
}

// DequeueAndProcess provides a mock function for the type mock_ioTargetQueue
func (_mock *mock_ioTargetQueue) DequeueAndProcess(ctx context.Context, processFunc func(*schema.Moveable) int) error {
	ret := _mock.Called(ctx, processFunc)

	if len(ret) == 0 {
		panic("no return value specified for DequeueAndProcess")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(*schema.Moveable) int) error); ok {
		r0 = returnFunc(ctx, processFunc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_ioTargetQueue_DequeueAndProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DequeueAndProcess'
type mock_ioTargetQueue_DequeueAndProcess_Call struct {
	*mock.Call
}

// DequeueAndProcess is a helper method to define mock.On call
//   - ctx context.Context
//   - processFunc func(*schema.Moveable) int
func (_e *mock_ioTargetQueue_Expecter) DequeueAndProcess(ctx interface{}, processFunc interface{}) *mock_ioTargetQueue_DequeueAndProcess_Call {
	return &mock_ioTargetQueue_DequeueAndProcess_Call{Call: _e.mock.On("DequeueAndProcess", ctx, processFunc)}
}

func (_c *mock_ioTargetQueue_DequeueAndProcess_Call) Run(run func(ctx context.Context, processFunc func(*schema.Moveable) int)) *mock_ioTargetQueue_DequeueAndProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(*schema.Moveable) int
		if args[1] != nil {
			arg1 = args[1].(func(*schema.Moveable) int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_ioTargetQueue_DequeueAndProcess_Call) Return(err error) *mock_ioTargetQueue_DequeueAndProcess_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_ioTargetQueue_DequeueAndProcess_Call) RunAndReturn(run func(ctx context.Context, processFunc func(*schema.Moveable) int) error) *mock_ioTargetQueue_DequeueAndProcess_Call {
	_c.Call.Return(run)
	return _c
}

// PostProcess provides a mock function for the type mock_ioTargetQueue
func (_mock *mock_ioTargetQueue) PostProcess(p schema.Pipeline[*schema.Moveable]) bool {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for PostProcess")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(schema.Pipeline[*schema.Moveable]) bool); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// mock_ioTargetQueue_PostProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostProcess'
type mock_ioTargetQueue_PostProcess_Call struct {
	*mock.Call
}

// PostProcess is a helper method to define mock.On call
//   - p schema.Pipeline[*schema.Moveable]
func (_e *mock_ioTargetQueue_Expecter) PostProcess(p interface{}) *mock_ioTargetQueue_PostProcess_Call {
	return &mock_ioTargetQueue_PostProcess_Call{Call: _e.mock.On("PostProcess", p)}
}

func (_c *mock_ioTargetQueue_PostProcess_Call) Run(run func(p schema.Pipeline[*schema.Moveable])) *mock_ioTargetQueue_PostProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.Pipeline[*schema.Moveable]
		if args[0] != nil {
			arg0 = args[0].(schema.Pipeline[*schema.Moveable])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_ioTargetQueue_PostProcess_Call) Return(b bool) *mock_ioTargetQueue_PostProcess_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *mock_ioTargetQueue_PostProcess_Call) RunAndReturn(run func(p schema.Pipeline[*schema.Moveable]) bool) *mock_ioTargetQueue_PostProcess_Call {
	_c.Call.Return(run)
	return _c
}

// PreProcess provides a mock function for the type mock_ioTargetQueue
func (_mock *mock_ioTargetQueue) PreProcess(p schema.Pipeline[*schema.Moveable]) bool {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for PreProcess")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(schema.Pipeline[*schema.Moveable]) bool); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// mock_ioTargetQueue_PreProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreProcess'
type mock_ioTargetQueue_PreProcess_Call struct {
	*mock.Call
}

// PreProcess is a helper method to define mock.On call
//   - p schema.Pipeline[*schema.Moveable]
func (_e *mock_ioTargetQueue_Expecter) PreProcess(p interface{}) *mock_ioTargetQueue_PreProcess_Call {
	return &mock_ioTargetQueue_PreProcess_Call{Call: _e.mock.On("PreProcess", p)}
}

func (_c *mock_ioTargetQueue_PreProcess_Call) Run(run func(p schema.Pipeline[*schema.Moveable])) *mock_ioTargetQueue_PreProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.Pipeline[*schema.Moveable]
		if args[0] != nil {
			arg0 = args[0].(schema.Pipeline[*schema.Moveable])
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_ioTargetQueue_PreProcess_Call) Return(b bool) *mock_ioTargetQueue_PreProcess_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *mock_ioTargetQueue_PreProcess_Call) RunAndReturn(run func(p schema.Pipeline[*schema.Moveable]) bool) *mock_ioTargetQueue_PreProcess_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_fsElement creates a new instance of mock_fsElement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_fsElement(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_fsElement {
	mock := &mock_fsElement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_fsElement is an autogenerated mock type for the fsElement type
type mock_fsElement struct {
	mock.Mock
}

type mock_fsElement_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_fsElement) EXPECT() *mock_fsElement_Expecter {
	return &mock_fsElement_Expecter{mock: &_m.Mock}
}

// GetDestPath provides a mock function for the type mock_fsElement
func (_mock *mock_fsElement) GetDestPath() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetDestPath")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// mock_fsElement_GetDestPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDestPath'
type mock_fsElement_GetDestPath_Call struct {
	*mock.Call
}

// GetDestPath is a helper method to define mock.On call
func (_e *mock_fsElement_Expecter) GetDestPath() *mock_fsElement_GetDestPath_Call {
	return &mock_fsElement_GetDestPath_Call{Call: _e.mock.On("GetDestPath")}
}

func (_c *mock_fsElement_GetDestPath_Call) Run(run func()) *mock_fsElement_GetDestPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mock_fsElement_GetDestPath_Call) Return(s string) *mock_fsElement_GetDestPath_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *mock_fsElement_GetDestPath_Call) RunAndReturn(run func() string) *mock_fsElement_GetDestPath_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetadata provides a mock function for the type mock_fsElement
func (_mock *mock_fsElement) GetMetadata() *schema.Metadata {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *schema.Metadata
	if returnFunc, ok := ret.Get(0).(func() *schema.Metadata); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.Metadata)
		}
	}
	return r0
}

// mock_fsElement_GetMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetadata'
type mock_fsElement_GetMetadata_Call struct {
	*mock.Call
}

// GetMetadata is a helper method to define mock.On call
func (_e *mock_fsElement_Expecter) GetMetadata() *mock_fsElement_GetMetadata_Call {
	return &mock_fsElement_GetMetadata_Call{Call: _e.mock.On("GetMetadata")}
}

func (_c *mock_fsElement_GetMetadata_Call) Run(run func()) *mock_fsElement_GetMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mock_fsElement_GetMetadata_Call) Return(metadata *schema.Metadata) *mock_fsElement_GetMetadata_Call {
	_c.Call.Return(metadata)
	return _c
}

func (_c *mock_fsElement_GetMetadata_Call) RunAndReturn(run func() *schema.Metadata) *mock_fsElement_GetMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetSourcePath provides a mock function for the type mock_fsElement
func (_mock *mock_fsElement) GetSourcePath() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSourcePath")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// mock_fsElement_GetSourcePath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSourcePath'
type mock_fsElement_GetSourcePath_Call struct {
	*mock.Call
}

// GetSourcePath is a helper method to define mock.On call
func (_e *mock_fsElement_Expecter) GetSourcePath() *mock_fsElement_GetSourcePath_Call {
	return &mock_fsElement_GetSourcePath_Call{Call: _e.mock.On("GetSourcePath")}
}

func (_c *mock_fsElement_GetSourcePath_Call) Run(run func()) *mock_fsElement_GetSourcePath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mock_fsElement_GetSourcePath_Call) Return(s string) *mock_fsElement_GetSourcePath_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *mock_fsElement_GetSourcePath_Call) RunAndReturn(run func() string) *mock_fsElement_GetSourcePath_Call {
	_c.Call.Return(run)
	return _c
}
