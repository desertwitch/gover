// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package filesystem

import (
	"io/fs"
	"os"

	"github.com/desertwitch/gover/internal/schema"
	mock "github.com/stretchr/testify/mock"
	"golang.org/x/sys/unix"
)

// newMock_unixStatfsProvider creates a new instance of mock_unixStatfsProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_unixStatfsProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_unixStatfsProvider {
	mock := &mock_unixStatfsProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_unixStatfsProvider is an autogenerated mock type for the unixStatfsProvider type
type mock_unixStatfsProvider struct {
	mock.Mock
}

type mock_unixStatfsProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_unixStatfsProvider) EXPECT() *mock_unixStatfsProvider_Expecter {
	return &mock_unixStatfsProvider_Expecter{mock: &_m.Mock}
}

// Statfs provides a mock function for the type mock_unixStatfsProvider
func (_mock *mock_unixStatfsProvider) Statfs(path string, buf *unix.Statfs_t) error {
	ret := _mock.Called(path, buf)

	if len(ret) == 0 {
		panic("no return value specified for Statfs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, *unix.Statfs_t) error); ok {
		r0 = returnFunc(path, buf)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixStatfsProvider_Statfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Statfs'
type mock_unixStatfsProvider_Statfs_Call struct {
	*mock.Call
}

// Statfs is a helper method to define mock.On call
//   - path string
//   - buf *unix.Statfs_t
func (_e *mock_unixStatfsProvider_Expecter) Statfs(path interface{}, buf interface{}) *mock_unixStatfsProvider_Statfs_Call {
	return &mock_unixStatfsProvider_Statfs_Call{Call: _e.mock.On("Statfs", path, buf)}
}

func (_c *mock_unixStatfsProvider_Statfs_Call) Run(run func(path string, buf *unix.Statfs_t)) *mock_unixStatfsProvider_Statfs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *unix.Statfs_t
		if args[1] != nil {
			arg1 = args[1].(*unix.Statfs_t)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixStatfsProvider_Statfs_Call) Return(err error) *mock_unixStatfsProvider_Statfs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixStatfsProvider_Statfs_Call) RunAndReturn(run func(path string, buf *unix.Statfs_t) error) *mock_unixStatfsProvider_Statfs_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_osProvider creates a new instance of mock_osProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_osProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_osProvider {
	mock := &mock_osProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_osProvider is an autogenerated mock type for the osProvider type
type mock_osProvider struct {
	mock.Mock
}

type mock_osProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_osProvider) EXPECT() *mock_osProvider_Expecter {
	return &mock_osProvider_Expecter{mock: &_m.Mock}
}

// Open provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Open(name string) (*os.File, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 *os.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*os.File, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *os.File); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type mock_osProvider_Open_Call struct {
	*mock.Call
}

// Open is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Open(name interface{}) *mock_osProvider_Open_Call {
	return &mock_osProvider_Open_Call{Call: _e.mock.On("Open", name)}
}

func (_c *mock_osProvider_Open_Call) Run(run func(name string)) *mock_osProvider_Open_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Open_Call) Return(file *os.File, err error) *mock_osProvider_Open_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *mock_osProvider_Open_Call) RunAndReturn(run func(name string) (*os.File, error)) *mock_osProvider_Open_Call {
	_c.Call.Return(run)
	return _c
}

// OpenFile provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	ret := _mock.Called(name, flag, perm)

	if len(ret) == 0 {
		panic("no return value specified for OpenFile")
	}

	var r0 *os.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, int, os.FileMode) (*os.File, error)); ok {
		return returnFunc(name, flag, perm)
	}
	if returnFunc, ok := ret.Get(0).(func(string, int, os.FileMode) *os.File); ok {
		r0 = returnFunc(name, flag, perm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, int, os.FileMode) error); ok {
		r1 = returnFunc(name, flag, perm)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_OpenFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenFile'
type mock_osProvider_OpenFile_Call struct {
	*mock.Call
}

// OpenFile is a helper method to define mock.On call
//   - name string
//   - flag int
//   - perm os.FileMode
func (_e *mock_osProvider_Expecter) OpenFile(name interface{}, flag interface{}, perm interface{}) *mock_osProvider_OpenFile_Call {
	return &mock_osProvider_OpenFile_Call{Call: _e.mock.On("OpenFile", name, flag, perm)}
}

func (_c *mock_osProvider_OpenFile_Call) Run(run func(name string, flag int, perm os.FileMode)) *mock_osProvider_OpenFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 os.FileMode
		if args[2] != nil {
			arg2 = args[2].(os.FileMode)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_osProvider_OpenFile_Call) Return(file *os.File, err error) *mock_osProvider_OpenFile_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *mock_osProvider_OpenFile_Call) RunAndReturn(run func(name string, flag int, perm os.FileMode) (*os.File, error)) *mock_osProvider_OpenFile_Call {
	_c.Call.Return(run)
	return _c
}

// ReadDir provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) ReadDir(name string) ([]os.DirEntry, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadDir")
	}

	var r0 []os.DirEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]os.DirEntry, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []os.DirEntry); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]os.DirEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_ReadDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadDir'
type mock_osProvider_ReadDir_Call struct {
	*mock.Call
}

// ReadDir is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) ReadDir(name interface{}) *mock_osProvider_ReadDir_Call {
	return &mock_osProvider_ReadDir_Call{Call: _e.mock.On("ReadDir", name)}
}

func (_c *mock_osProvider_ReadDir_Call) Run(run func(name string)) *mock_osProvider_ReadDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_ReadDir_Call) Return(vs []os.DirEntry, err error) *mock_osProvider_ReadDir_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *mock_osProvider_ReadDir_Call) RunAndReturn(run func(name string) ([]os.DirEntry, error)) *mock_osProvider_ReadDir_Call {
	_c.Call.Return(run)
	return _c
}

// Readlink provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Readlink(name string) (string, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Readlink")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_Readlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Readlink'
type mock_osProvider_Readlink_Call struct {
	*mock.Call
}

// Readlink is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Readlink(name interface{}) *mock_osProvider_Readlink_Call {
	return &mock_osProvider_Readlink_Call{Call: _e.mock.On("Readlink", name)}
}

func (_c *mock_osProvider_Readlink_Call) Run(run func(name string)) *mock_osProvider_Readlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Readlink_Call) Return(s string, err error) *mock_osProvider_Readlink_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *mock_osProvider_Readlink_Call) RunAndReturn(run func(name string) (string, error)) *mock_osProvider_Readlink_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Remove(name string) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_osProvider_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type mock_osProvider_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Remove(name interface{}) *mock_osProvider_Remove_Call {
	return &mock_osProvider_Remove_Call{Call: _e.mock.On("Remove", name)}
}

func (_c *mock_osProvider_Remove_Call) Run(run func(name string)) *mock_osProvider_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Remove_Call) Return(err error) *mock_osProvider_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_osProvider_Remove_Call) RunAndReturn(run func(name string) error) *mock_osProvider_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Rename(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_osProvider_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type mock_osProvider_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_osProvider_Expecter) Rename(oldpath interface{}, newpath interface{}) *mock_osProvider_Rename_Call {
	return &mock_osProvider_Rename_Call{Call: _e.mock.On("Rename", oldpath, newpath)}
}

func (_c *mock_osProvider_Rename_Call) Run(run func(oldpath string, newpath string)) *mock_osProvider_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_osProvider_Rename_Call) Return(err error) *mock_osProvider_Rename_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_osProvider_Rename_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_osProvider_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// Stat provides a mock function for the type mock_osProvider
func (_mock *mock_osProvider) Stat(name string) (os.FileInfo, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Stat")
	}

	var r0 os.FileInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (os.FileInfo, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) os.FileInfo); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(os.FileInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osProvider_Stat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stat'
type mock_osProvider_Stat_Call struct {
	*mock.Call
}

// Stat is a helper method to define mock.On call
//   - name string
func (_e *mock_osProvider_Expecter) Stat(name interface{}) *mock_osProvider_Stat_Call {
	return &mock_osProvider_Stat_Call{Call: _e.mock.On("Stat", name)}
}

func (_c *mock_osProvider_Stat_Call) Run(run func(name string)) *mock_osProvider_Stat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osProvider_Stat_Call) Return(v os.FileInfo, err error) *mock_osProvider_Stat_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *mock_osProvider_Stat_Call) RunAndReturn(run func(name string) (os.FileInfo, error)) *mock_osProvider_Stat_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_unixProvider creates a new instance of mock_unixProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_unixProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_unixProvider {
	mock := &mock_unixProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_unixProvider is an autogenerated mock type for the unixProvider type
type mock_unixProvider struct {
	mock.Mock
}

type mock_unixProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_unixProvider) EXPECT() *mock_unixProvider_Expecter {
	return &mock_unixProvider_Expecter{mock: &_m.Mock}
}

// Chmod provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Chmod(path string, mode uint32) error {
	ret := _mock.Called(path, mode)

	if len(ret) == 0 {
		panic("no return value specified for Chmod")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, uint32) error); ok {
		r0 = returnFunc(path, mode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Chmod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chmod'
type mock_unixProvider_Chmod_Call struct {
	*mock.Call
}

// Chmod is a helper method to define mock.On call
//   - path string
//   - mode uint32
func (_e *mock_unixProvider_Expecter) Chmod(path interface{}, mode interface{}) *mock_unixProvider_Chmod_Call {
	return &mock_unixProvider_Chmod_Call{Call: _e.mock.On("Chmod", path, mode)}
}

func (_c *mock_unixProvider_Chmod_Call) Run(run func(path string, mode uint32)) *mock_unixProvider_Chmod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Chmod_Call) Return(err error) *mock_unixProvider_Chmod_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Chmod_Call) RunAndReturn(run func(path string, mode uint32) error) *mock_unixProvider_Chmod_Call {
	_c.Call.Return(run)
	return _c
}

// Chown provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Chown(path string, uid int, gid int) error {
	ret := _mock.Called(path, uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Chown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = returnFunc(path, uid, gid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Chown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chown'
type mock_unixProvider_Chown_Call struct {
	*mock.Call
}

// Chown is a helper method to define mock.On call
//   - path string
//   - uid int
//   - gid int
func (_e *mock_unixProvider_Expecter) Chown(path interface{}, uid interface{}, gid interface{}) *mock_unixProvider_Chown_Call {
	return &mock_unixProvider_Chown_Call{Call: _e.mock.On("Chown", path, uid, gid)}
}

func (_c *mock_unixProvider_Chown_Call) Run(run func(path string, uid int, gid int)) *mock_unixProvider_Chown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Chown_Call) Return(err error) *mock_unixProvider_Chown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Chown_Call) RunAndReturn(run func(path string, uid int, gid int) error) *mock_unixProvider_Chown_Call {
	_c.Call.Return(run)
	return _c
}

// Lchown provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Lchown(path string, uid int, gid int) error {
	ret := _mock.Called(path, uid, gid)

	if len(ret) == 0 {
		panic("no return value specified for Lchown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, int, int) error); ok {
		r0 = returnFunc(path, uid, gid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Lchown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lchown'
type mock_unixProvider_Lchown_Call struct {
	*mock.Call
}

// Lchown is a helper method to define mock.On call
//   - path string
//   - uid int
//   - gid int
func (_e *mock_unixProvider_Expecter) Lchown(path interface{}, uid interface{}, gid interface{}) *mock_unixProvider_Lchown_Call {
	return &mock_unixProvider_Lchown_Call{Call: _e.mock.On("Lchown", path, uid, gid)}
}

func (_c *mock_unixProvider_Lchown_Call) Run(run func(path string, uid int, gid int)) *mock_unixProvider_Lchown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Lchown_Call) Return(err error) *mock_unixProvider_Lchown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Lchown_Call) RunAndReturn(run func(path string, uid int, gid int) error) *mock_unixProvider_Lchown_Call {
	_c.Call.Return(run)
	return _c
}

// Link provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Link(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Link")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Link_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Link'
type mock_unixProvider_Link_Call struct {
	*mock.Call
}

// Link is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_unixProvider_Expecter) Link(oldpath interface{}, newpath interface{}) *mock_unixProvider_Link_Call {
	return &mock_unixProvider_Link_Call{Call: _e.mock.On("Link", oldpath, newpath)}
}

func (_c *mock_unixProvider_Link_Call) Run(run func(oldpath string, newpath string)) *mock_unixProvider_Link_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Link_Call) Return(err error) *mock_unixProvider_Link_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Link_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_unixProvider_Link_Call {
	_c.Call.Return(run)
	return _c
}

// Lstat provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Lstat(path string, stat *unix.Stat_t) error {
	ret := _mock.Called(path, stat)

	if len(ret) == 0 {
		panic("no return value specified for Lstat")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, *unix.Stat_t) error); ok {
		r0 = returnFunc(path, stat)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Lstat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lstat'
type mock_unixProvider_Lstat_Call struct {
	*mock.Call
}

// Lstat is a helper method to define mock.On call
//   - path string
//   - stat *unix.Stat_t
func (_e *mock_unixProvider_Expecter) Lstat(path interface{}, stat interface{}) *mock_unixProvider_Lstat_Call {
	return &mock_unixProvider_Lstat_Call{Call: _e.mock.On("Lstat", path, stat)}
}

func (_c *mock_unixProvider_Lstat_Call) Run(run func(path string, stat *unix.Stat_t)) *mock_unixProvider_Lstat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *unix.Stat_t
		if args[1] != nil {
			arg1 = args[1].(*unix.Stat_t)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Lstat_Call) Return(err error) *mock_unixProvider_Lstat_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Lstat_Call) RunAndReturn(run func(path string, stat *unix.Stat_t) error) *mock_unixProvider_Lstat_Call {
	_c.Call.Return(run)
	return _c
}

// Mkdir provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Mkdir(path string, mode uint32) error {
	ret := _mock.Called(path, mode)

	if len(ret) == 0 {
		panic("no return value specified for Mkdir")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, uint32) error); ok {
		r0 = returnFunc(path, mode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Mkdir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Mkdir'
type mock_unixProvider_Mkdir_Call struct {
	*mock.Call
}

// Mkdir is a helper method to define mock.On call
//   - path string
//   - mode uint32
func (_e *mock_unixProvider_Expecter) Mkdir(path interface{}, mode interface{}) *mock_unixProvider_Mkdir_Call {
	return &mock_unixProvider_Mkdir_Call{Call: _e.mock.On("Mkdir", path, mode)}
}

func (_c *mock_unixProvider_Mkdir_Call) Run(run func(path string, mode uint32)) *mock_unixProvider_Mkdir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 uint32
		if args[1] != nil {
			arg1 = args[1].(uint32)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Mkdir_Call) Return(err error) *mock_unixProvider_Mkdir_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Mkdir_Call) RunAndReturn(run func(path string, mode uint32) error) *mock_unixProvider_Mkdir_Call {
	_c.Call.Return(run)
	return _c
}

// Statfs provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Statfs(path string, buf *unix.Statfs_t) error {
	ret := _mock.Called(path, buf)

	if len(ret) == 0 {
		panic("no return value specified for Statfs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, *unix.Statfs_t) error); ok {
		r0 = returnFunc(path, buf)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Statfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Statfs'
type mock_unixProvider_Statfs_Call struct {
	*mock.Call
}

// Statfs is a helper method to define mock.On call
//   - path string
//   - buf *unix.Statfs_t
func (_e *mock_unixProvider_Expecter) Statfs(path interface{}, buf interface{}) *mock_unixProvider_Statfs_Call {
	return &mock_unixProvider_Statfs_Call{Call: _e.mock.On("Statfs", path, buf)}
}

func (_c *mock_unixProvider_Statfs_Call) Run(run func(path string, buf *unix.Statfs_t)) *mock_unixProvider_Statfs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *unix.Statfs_t
		if args[1] != nil {
			arg1 = args[1].(*unix.Statfs_t)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Statfs_Call) Return(err error) *mock_unixProvider_Statfs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Statfs_Call) RunAndReturn(run func(path string, buf *unix.Statfs_t) error) *mock_unixProvider_Statfs_Call {
	_c.Call.Return(run)
	return _c
}

// Symlink provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) Symlink(oldpath string, newpath string) error {
	ret := _mock.Called(oldpath, newpath)

	if len(ret) == 0 {
		panic("no return value specified for Symlink")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(oldpath, newpath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_Symlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Symlink'
type mock_unixProvider_Symlink_Call struct {
	*mock.Call
}

// Symlink is a helper method to define mock.On call
//   - oldpath string
//   - newpath string
func (_e *mock_unixProvider_Expecter) Symlink(oldpath interface{}, newpath interface{}) *mock_unixProvider_Symlink_Call {
	return &mock_unixProvider_Symlink_Call{Call: _e.mock.On("Symlink", oldpath, newpath)}
}

func (_c *mock_unixProvider_Symlink_Call) Run(run func(oldpath string, newpath string)) *mock_unixProvider_Symlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_Symlink_Call) Return(err error) *mock_unixProvider_Symlink_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_Symlink_Call) RunAndReturn(run func(oldpath string, newpath string) error) *mock_unixProvider_Symlink_Call {
	_c.Call.Return(run)
	return _c
}

// UtimesNano provides a mock function for the type mock_unixProvider
func (_mock *mock_unixProvider) UtimesNano(path string, times []unix.Timespec) error {
	ret := _mock.Called(path, times)

	if len(ret) == 0 {
		panic("no return value specified for UtimesNano")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, []unix.Timespec) error); ok {
		r0 = returnFunc(path, times)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_unixProvider_UtimesNano_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UtimesNano'
type mock_unixProvider_UtimesNano_Call struct {
	*mock.Call
}

// UtimesNano is a helper method to define mock.On call
//   - path string
//   - times []unix.Timespec
func (_e *mock_unixProvider_Expecter) UtimesNano(path interface{}, times interface{}) *mock_unixProvider_UtimesNano_Call {
	return &mock_unixProvider_UtimesNano_Call{Call: _e.mock.On("UtimesNano", path, times)}
}

func (_c *mock_unixProvider_UtimesNano_Call) Run(run func(path string, times []unix.Timespec)) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []unix.Timespec
		if args[1] != nil {
			arg1 = args[1].([]unix.Timespec)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_unixProvider_UtimesNano_Call) Return(err error) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_unixProvider_UtimesNano_Call) RunAndReturn(run func(path string, times []unix.Timespec) error) *mock_unixProvider_UtimesNano_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_inUseProvider creates a new instance of mock_inUseProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_inUseProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_inUseProvider {
	mock := &mock_inUseProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_inUseProvider is an autogenerated mock type for the inUseProvider type
type mock_inUseProvider struct {
	mock.Mock
}

type mock_inUseProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_inUseProvider) EXPECT() *mock_inUseProvider_Expecter {
	return &mock_inUseProvider_Expecter{mock: &_m.Mock}
}

// IsInUse provides a mock function for the type mock_inUseProvider
func (_mock *mock_inUseProvider) IsInUse(path string) bool {
	ret := _mock.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for IsInUse")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(path)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// mock_inUseProvider_IsInUse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsInUse'
type mock_inUseProvider_IsInUse_Call struct {
	*mock.Call
}

// IsInUse is a helper method to define mock.On call
//   - path string
func (_e *mock_inUseProvider_Expecter) IsInUse(path interface{}) *mock_inUseProvider_IsInUse_Call {
	return &mock_inUseProvider_IsInUse_Call{Call: _e.mock.On("IsInUse", path)}
}

func (_c *mock_inUseProvider_IsInUse_Call) Run(run func(path string)) *mock_inUseProvider_IsInUse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_inUseProvider_IsInUse_Call) Return(b bool) *mock_inUseProvider_IsInUse_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *mock_inUseProvider_IsInUse_Call) RunAndReturn(run func(path string) bool) *mock_inUseProvider_IsInUse_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_fsWalkProvider creates a new instance of mock_fsWalkProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_fsWalkProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_fsWalkProvider {
	mock := &mock_fsWalkProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_fsWalkProvider is an autogenerated mock type for the fsWalkProvider type
type mock_fsWalkProvider struct {
	mock.Mock
}

type mock_fsWalkProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_fsWalkProvider) EXPECT() *mock_fsWalkProvider_Expecter {
	return &mock_fsWalkProvider_Expecter{mock: &_m.Mock}
}

// WalkDir provides a mock function for the type mock_fsWalkProvider
func (_mock *mock_fsWalkProvider) WalkDir(root string, fn fs.WalkDirFunc) error {
	ret := _mock.Called(root, fn)

	if len(ret) == 0 {
		panic("no return value specified for WalkDir")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, fs.WalkDirFunc) error); ok {
		r0 = returnFunc(root, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mock_fsWalkProvider_WalkDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalkDir'
type mock_fsWalkProvider_WalkDir_Call struct {
	*mock.Call
}

// WalkDir is a helper method to define mock.On call
//   - root string
//   - fn fs.WalkDirFunc
func (_e *mock_fsWalkProvider_Expecter) WalkDir(root interface{}, fn interface{}) *mock_fsWalkProvider_WalkDir_Call {
	return &mock_fsWalkProvider_WalkDir_Call{Call: _e.mock.On("WalkDir", root, fn)}
}

func (_c *mock_fsWalkProvider_WalkDir_Call) Run(run func(root string, fn fs.WalkDirFunc)) *mock_fsWalkProvider_WalkDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 fs.WalkDirFunc
		if args[1] != nil {
			arg1 = args[1].(fs.WalkDirFunc)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mock_fsWalkProvider_WalkDir_Call) Return(err error) *mock_fsWalkProvider_WalkDir_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mock_fsWalkProvider_WalkDir_Call) RunAndReturn(run func(root string, fn fs.WalkDirFunc) error) *mock_fsWalkProvider_WalkDir_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_diskStatProvider creates a new instance of mock_diskStatProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_diskStatProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_diskStatProvider {
	mock := &mock_diskStatProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_diskStatProvider is an autogenerated mock type for the diskStatProvider type
type mock_diskStatProvider struct {
	mock.Mock
}

type mock_diskStatProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_diskStatProvider) EXPECT() *mock_diskStatProvider_Expecter {
	return &mock_diskStatProvider_Expecter{mock: &_m.Mock}
}

// GetDiskUsage provides a mock function for the type mock_diskStatProvider
func (_mock *mock_diskStatProvider) GetDiskUsage(storage schema.Storage) (DiskStats, error) {
	ret := _mock.Called(storage)

	if len(ret) == 0 {
		panic("no return value specified for GetDiskUsage")
	}

	var r0 DiskStats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(schema.Storage) (DiskStats, error)); ok {
		return returnFunc(storage)
	}
	if returnFunc, ok := ret.Get(0).(func(schema.Storage) DiskStats); ok {
		r0 = returnFunc(storage)
	} else {
		r0 = ret.Get(0).(DiskStats)
	}
	if returnFunc, ok := ret.Get(1).(func(schema.Storage) error); ok {
		r1 = returnFunc(storage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_diskStatProvider_GetDiskUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDiskUsage'
type mock_diskStatProvider_GetDiskUsage_Call struct {
	*mock.Call
}

// GetDiskUsage is a helper method to define mock.On call
//   - storage schema.Storage
func (_e *mock_diskStatProvider_Expecter) GetDiskUsage(storage interface{}) *mock_diskStatProvider_GetDiskUsage_Call {
	return &mock_diskStatProvider_GetDiskUsage_Call{Call: _e.mock.On("GetDiskUsage", storage)}
}

func (_c *mock_diskStatProvider_GetDiskUsage_Call) Run(run func(storage schema.Storage)) *mock_diskStatProvider_GetDiskUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.Storage
		if args[0] != nil {
			arg0 = args[0].(schema.Storage)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_diskStatProvider_GetDiskUsage_Call) Return(diskStats DiskStats, err error) *mock_diskStatProvider_GetDiskUsage_Call {
	_c.Call.Return(diskStats, err)
	return _c
}

func (_c *mock_diskStatProvider_GetDiskUsage_Call) RunAndReturn(run func(storage schema.Storage) (DiskStats, error)) *mock_diskStatProvider_GetDiskUsage_Call {
	_c.Call.Return(run)
	return _c
}

// HasEnoughFreeSpace provides a mock function for the type mock_diskStatProvider
func (_mock *mock_diskStatProvider) HasEnoughFreeSpace(s schema.Storage, minFree uint64, fileSize uint64) (bool, error) {
	ret := _mock.Called(s, minFree, fileSize)

	if len(ret) == 0 {
		panic("no return value specified for HasEnoughFreeSpace")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(schema.Storage, uint64, uint64) (bool, error)); ok {
		return returnFunc(s, minFree, fileSize)
	}
	if returnFunc, ok := ret.Get(0).(func(schema.Storage, uint64, uint64) bool); ok {
		r0 = returnFunc(s, minFree, fileSize)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(schema.Storage, uint64, uint64) error); ok {
		r1 = returnFunc(s, minFree, fileSize)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_diskStatProvider_HasEnoughFreeSpace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasEnoughFreeSpace'
type mock_diskStatProvider_HasEnoughFreeSpace_Call struct {
	*mock.Call
}

// HasEnoughFreeSpace is a helper method to define mock.On call
//   - s schema.Storage
//   - minFree uint64
//   - fileSize uint64
func (_e *mock_diskStatProvider_Expecter) HasEnoughFreeSpace(s interface{}, minFree interface{}, fileSize interface{}) *mock_diskStatProvider_HasEnoughFreeSpace_Call {
	return &mock_diskStatProvider_HasEnoughFreeSpace_Call{Call: _e.mock.On("HasEnoughFreeSpace", s, minFree, fileSize)}
}

func (_c *mock_diskStatProvider_HasEnoughFreeSpace_Call) Run(run func(s schema.Storage, minFree uint64, fileSize uint64)) *mock_diskStatProvider_HasEnoughFreeSpace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 schema.Storage
		if args[0] != nil {
			arg0 = args[0].(schema.Storage)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mock_diskStatProvider_HasEnoughFreeSpace_Call) Return(b bool, err error) *mock_diskStatProvider_HasEnoughFreeSpace_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mock_diskStatProvider_HasEnoughFreeSpace_Call) RunAndReturn(run func(s schema.Storage, minFree uint64, fileSize uint64) (bool, error)) *mock_diskStatProvider_HasEnoughFreeSpace_Call {
	_c.Call.Return(run)
	return _c
}

// newMock_osReadsProvider creates a new instance of mock_osReadsProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMock_osReadsProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *mock_osReadsProvider {
	mock := &mock_osReadsProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mock_osReadsProvider is an autogenerated mock type for the osReadsProvider type
type mock_osReadsProvider struct {
	mock.Mock
}

type mock_osReadsProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *mock_osReadsProvider) EXPECT() *mock_osReadsProvider_Expecter {
	return &mock_osReadsProvider_Expecter{mock: &_m.Mock}
}

// ReadDir provides a mock function for the type mock_osReadsProvider
func (_mock *mock_osReadsProvider) ReadDir(name string) ([]os.DirEntry, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadDir")
	}

	var r0 []os.DirEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]os.DirEntry, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []os.DirEntry); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]os.DirEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osReadsProvider_ReadDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadDir'
type mock_osReadsProvider_ReadDir_Call struct {
	*mock.Call
}

// ReadDir is a helper method to define mock.On call
//   - name string
func (_e *mock_osReadsProvider_Expecter) ReadDir(name interface{}) *mock_osReadsProvider_ReadDir_Call {
	return &mock_osReadsProvider_ReadDir_Call{Call: _e.mock.On("ReadDir", name)}
}

func (_c *mock_osReadsProvider_ReadDir_Call) Run(run func(name string)) *mock_osReadsProvider_ReadDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osReadsProvider_ReadDir_Call) Return(vs []os.DirEntry, err error) *mock_osReadsProvider_ReadDir_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *mock_osReadsProvider_ReadDir_Call) RunAndReturn(run func(name string) ([]os.DirEntry, error)) *mock_osReadsProvider_ReadDir_Call {
	_c.Call.Return(run)
	return _c
}

// Readlink provides a mock function for the type mock_osReadsProvider
func (_mock *mock_osReadsProvider) Readlink(name string) (string, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Readlink")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mock_osReadsProvider_Readlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Readlink'
type mock_osReadsProvider_Readlink_Call struct {
	*mock.Call
}

// Readlink is a helper method to define mock.On call
//   - name string
func (_e *mock_osReadsProvider_Expecter) Readlink(name interface{}) *mock_osReadsProvider_Readlink_Call {
	return &mock_osReadsProvider_Readlink_Call{Call: _e.mock.On("Readlink", name)}
}

func (_c *mock_osReadsProvider_Readlink_Call) Run(run func(name string)) *mock_osReadsProvider_Readlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mock_osReadsProvider_Readlink_Call) Return(s string, err error) *mock_osReadsProvider_Readlink_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *mock_osReadsProvider_Readlink_Call) RunAndReturn(run func(name string) (string, error)) *mock_osReadsProvider_Readlink_Call {
	_c.Call.Return(run)
	return _c
}
